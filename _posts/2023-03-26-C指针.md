---
layout: article
title: C指针
tags: c&c++
mathjax: true
key: A-2023-03-26_2


---

C指针

<!--more-->

***

## 指针的基本介绍

[参考视频](https://www.bilibili.com/video/BV1bo4y1Z7xf/?spm_id_from=333.999.0.0&vd_source=216422f9c92c0e837a651f3b47974a0c)

![image-20230312120351917](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230312120351917.png)

`int`型占用4字节，`char`占用1字节，`float`占用4字节，上图为内存中的占用位置

***

![image-20230312120628235](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230312120628235.png)

指针是一个变量，它用来存放其他变量的地址。

***

![image-20230312120736716](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230312120736716.png)

***

## 指针代码示例

![image-20230312120802961](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230312120802961.png)

可以通过`*p = b`的方式为指针所指向的地址赋值。

***

![image-20230312120926461](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230312120926461.png)

* 整型指针+1相当于前进四个字节，而此时`*(p+1)`由于之前没有给其赋值，因此其对应的值是无效的。

* ***

## 指针的类型，算术运算，void指针

![image-20230312121146080](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230312121146080.png)

* 指针是强类型数据，原因：不同类型有不同的存储大小，同时需要解引用和写数据，因此必须为强类型数据

  ***

![image-20230312121316603](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230312121316603.png)

这里通过转换指针类型`p0 = (char*)p`，对其进行解引用之后`*(p0+1)`的值变成4，对应上图中的二进制，`char`型数据+1时候对应地址会前进一位，此时指向了倒数第二个字节，也就是4.

***

![image-20230312121602374](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230312121602374.png)

这里`void`指针如果直接被赋值，可以打印出指针所在的地址，但是无法直接对其解引用，因为其没有指向任何一个值。

***

![image-20230312121654880](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230312121654880.png)

同理：`void`指针中`p0+1`也是不行的。	有编译错误

**总结：`&`用来取地址，`*`用来解引用，`int*`用来定义指针**

```c
//指针可以这样定义
int a = 105;
int *p;
p = &a;
//也可以直接这样定义
int a = 105;
int *p = &a;
```

***

## 指向指针的指针

![image-20230312122148692](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230312122148692.png)

上图中，`*p`是解引用操作，也就是得到`x`的值，`*q`是对`p`进行解引用，得到的是`p`的值，也就是指向`x`指针的地址值，`*(*q)`双解引用，最终得到`x`的值。

**也就是`*`起到一个解引用的作用，一层一层剥洋葱一样**

***

![image-20230312122511543](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230312122511543.png)

最后用`***r`给`x`赋值，因此其他对应的值也都发生了改变。

***

## 函数传值 vs 传引用

![image-20230312122653379](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230312122653379.png)

上面就是函数传值的过程，最终并没有实现主函数中`+1`的操作

***

![image-20230312122733113](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230312122733113.png)

可以看到两个`a`的地址根本不同，因此不可能实现加一操作。

***

![image-20230312122821627](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230312122821627.png)

局部函数的生命周期在函数执行期间一直存在，当执行main()函数时候，此时main()函数的栈帧保存了该函数的返回地址和局部变量，如图所示。当运行到`Increment(a)`时，main()函数停止，进入Increment(a)函数中，然后运行之后只是改变了Increment(a)中的a的值，main()函数中a的值并未改变，因此并未实现传值操作。最后调用printf库函数，调用栈/函数调用栈。如果一个函数无限调用另外一个函数，栈会溢出。

**实参映射到形参**

***

![image-20230312123344785](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230312123344785.png)

传引用的时候，此时在Increment()函数中传回去的只是对应的地址，因此在该函数中执行解引用操作会使得值加1，也就是改变了main()栈帧中局部变量a的值。

***

## 指针和数组

![image-20230312124220811](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230312124220811.png)

对于整型`int x = 5;`来说，如上图，无法定位到`*(p+1)`对应的值，因为其并没有被赋值

***

![image-20230312124546323](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230312124546323.png)

对于索引`i`处的元素：

> 地址：&A[i] 或 (A+i)
>
> 值：A[i] 或 *(A+i)

**注：A对应数组中第一个元素的地址，基地址**

***

![image-20230312124844181](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230312124844181.png)

![image-20230312125012339](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230312125012339.png)

![image-20230312125026889](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230312125026889.png)

***

![image-20230312125136327](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230312125136327.png)

**注意：可以使用一个指针`*p`来进行++操作，但是直接对数组的基地址`A`操作是非法的。**

***

## 数组作为函数参数

![image-20230312125558324](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230312125558324.png)

![image-20230312125651552](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230312125651552.png)

![image-20230312125736468](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230312125736468.png)

![image-20230312130255218](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230312130255218.png)

在数组作为函数参数时候，编译器会认为传入的只是数组元素的基地址，也就是会将`int A[]`认为是`int* A`,因此无法在函数中得到数组的大小。

****

因此代码如下：

![image-20230312130715985](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230312130715985.png)

***

**同样也可以在调用函数中修改元素的值（通过传引用的方式）**

![image-20230312130909288](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230312130909288.png)

***

## 指针和字符数组（上）（字符串）

  ![image-20230312141210461](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230312141210461.png)

**如何存储字符串？**

数组的长度应该>=字符串的长度加1

"john" size>=5		

**还需要加入一个结束字符，也就是'\0'**

***

![image-20230312141407001](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230312141407001.png)

![image-20230312141442259](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230312141442259.png)

![image-20230312141536995](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230312141536995.png)

**数组长度计算到'\0'停止**

***

![image-20230312141752011](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230312141752011.png)

上述中字符串占用字节数为5，数组长度为4

此时定义`char C[4] = "JOHN";`将时错误的，至少为5

另外一种初始化方式：

![image-20230312142002546](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230312142002546.png)

***

* 尽管数组和指针有时候使用起来非常相似，但是他们并不是一个类型，

![image-20230312142804630](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230312142804630.png)

***

* 数组作为函数的参数时只是传的是数组的引用，也就是基地址，不会拷贝数组，编译器不允许这样做。

![image-20230312143142692](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230312143142692.png)

![image-20230312143247298](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230312143247298.png)

***

## 指针和字符数组（下）

![image-20230312144047587](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230312144047587.png)

结束后，print()函数的栈帧被清除

***

![image-20230312144200937](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230312144200937.png)

`char *C = "Hello"`存储在常量区，字符不能被修改，`C[0]='A'`报错

`char C[20] = "Hello"`存储在栈区，可以被修改。

***

![image-20230312144632721](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230312144632721.png)

**使用`const char *c`形参数可以控制字符只读，不被写。**

***

## 指针和二维数组

复习之前的一维数组

![image-20230312145905965](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230312145905965.png)

***

![image-20230312150719614](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230312150719614.png)

![image-20230312150823698](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230312150823698.png)

***

## 指针和多维数组

![image-20230312201119669](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230312201119669.png)

![image-20230312201405818](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230312201405818.png)

![image-20230312201718954](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230312201718954.png)

![image-20230312201810546](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230312201810546.png)

![image-20230312201937093](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230312201937093.png)

**关于多维数组函数传参的问题**

```c
#include <stdio.h>
void Func(int *A){	//一维数组函数传参

}
void Func(int (*A)[3]){	//二维数组函数传参
    
}
void Func(int (*A)[2][2]){// 三维数组函数传参

}
int main(){
    int A[2] = {1,2};//一维数组
    int B[2][3] = {{2,4,6},{5,7,8}};	//二维数组
    int C[3][2][2] = {{{2,5},{7,9}},
                      {{3,4},{6,1}},
                      {{0,8},{1,10}}};
    return 0;
}
```

***

## 一维数组&二维数组&三维数组代码示例

```c
#include <stdio.h>
int main() {

	int A[2] = { 1,2 };//一维数组

	int B[2][3] = {		//二维数组
	{ 2,3,4},
	{ 5,6,7}
	};

	int C[3][2][2] = { {{2,5},{7,9}},	//三维数组
				  {{3,4},{6,1}},
				  {{0,8},{1,10}} };
	int* q = A;
	printf("*****************一维数据*******************************************\n");
	printf("A:%d    *A:%d\n", A, *A);		//A为数组的首地址，*A表示数组第一个元素 
	printf("&A[1]:%d    A+1:%d\n", &A[1], A + 1);		//两个都表示索引为1的元素的地址
	printf("A[1]:%d    *(A+1):%d\n", A[1], *(A + 1));	//两个都表示第1个元素的值，前面是直接访问，后面是解引用
	
	// 一维数组
	// *(A+i) = A[i]	第i个元素的值
	// (A+1) = &A[i]	第i个元素的地址

	int(*p)[3] = B; 
	printf("*****************二维数据*******************************************\n");
	printf("B:%d    B[0]:%d    &B[0]:%d\n",B, B[0], &B[0]);	//两个都是二维数组的首地址
	printf("*B:%d    B[0]:%d    &B[0][0]:%d\n", *B, B[0], &B[0][0]);	//三个都是二维数组的首地址
	printf("B+1:%d    &B[1]:%d\n",B+1,&B[1]);		//二维数组中第二层元素的首地址
	printf("*(B+1):%d    B[1]:%d    &B[1][0]:%d\n", *(B + 1), B[1], &B[1][0]);		//二维数组中第二层元素的首地址 412
	printf("*(B+1)+2:%d    B[1]+2:%d    &B[1][2]:%d\n", *(B + 1)+2, B[1]+2, &B[1][2]);	//二维数组中第二层元素的首地址再往后两个字节，比如 412->420
	printf("*(*B+1):%d    B[0][1]:%d\n", *(*B + 1), B[0][1]);		//3

	// 二维数组
	// B[i][j] = *(B[i] + j) = *(*(B+i) + j);
	int(*z)[2][2] = C;
	printf("*****************三维数据*******************************************\n");
	printf("C:%d\n", C);	//三维数组的首地址
	printf("*C:%d    C[0]:%d     &C[0][0]:%d\n", *C, C[0], &C[0][0]);	//三维数组的首地址
	printf("*(C[0][1]+1):%d    C[0][1][1]:%d\n", *(C[0][1] + 1), C[0][1][1]);	//9
	printf("*(C[1]+1):%d    C[1][1]:%d    &C[1][1][0]:%d\n", *(C[1] + 1), C[1][1], &C[1][1][0]);	//索引为 1，1的一维数组的首地址

	// 三维数组
	// C[i][j][k] = *(C[i][j]+k) = *(*(C[i]+j)+k) = *(*(*(C+i)+j)+k)
	//printf("hello world");
	return 0;
}
```

运行结果如下：

![image-20230312211906664](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230312211906664.png)

***

## 指针和动态内存-栈 vs 堆

![](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230312213402477.png)

* code：代码段，存储需要执行的指令
* Static/Global:存储静态或者全局变量
* stack(栈)：存储调用函数的所有信息以及局部变量
* heap(堆)：随时分配内存，只要不超出系统自身的内存限制。**内存空闲存取区**

![image-20230312213545134](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230312213545134.png)

* **栈溢出（StackOverflow）**：编译器会预留给栈固定的空间，不会在运行过程中变化，因此如果一直递归调用函数，可能就会导致栈溢出。运行期间不会请求更多的栈。

  当一个函数被调用时候，其被压入栈，结束时候弹出栈

  如果声明一个很大的数组作为局部变量，就有可能栈溢出，分配了太多的内存。

  在运行期间需要根据参数决定数组的大小，或者分配很大的内存空间，或者把变量预留在内存中直到我们想用的时候为止，**需要引入堆(heap)**。 

***

**堆：**对于程序员而言就是一块很大的可以自由使用的内存，根据需要来灵活取用，**因此堆也称为动态内存**，这里的堆和数据结构中的堆不一样

![image-20230312214702196](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230312214702196.png)

**C/C++中动态内存的使用**

> C：malloc  calloc  realloc  free
>
> C++: new  delete

![image-20230312215239157](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230312215239157.png)

```c
#include <stdio.h>
#include<stdlib.h>//要调用malloc函数必须的库
int main() {
	int a;	//分配在栈上
	int* p;
	p = (int*)malloc(sizeof(int));	//在堆上申请内存，malloc返回值为void，需要强制类型转换
    
    // C++
    p = new int;
    
	*p = 10;
    // C++
    delete p;
    
	free(p);	//使用完堆上的内存之后需要手动释放，否则会内存泄露
	p = (int*)malloc(20 * sizeof(int));	//二维数组

	// malloc 和 free c++中为new 和 delete
    // 不同点：malloc的返回值为void new自带返回值
	
	//注意释放数组时候
	delete[] p;

}
```

***

## 指针和动态内存-malloc calloc realloc free

* **malloc - void* malloc(size_t size) size是无符号整形 >=0,返回值为void** 

`void *p = malloc(10*sizeof(int));`通常我们会首先计算出需要多少内存，比如一个整形，先计算需要多少内存`sizeof(int)`

**总共需要的字节数：单元的数量*每个单元的字节数**

```c
//进行强制类型转换
int *p = (int *)malloc(10*sizeof(int));
```

* **calloc - void* calloc(size_t num,size_t size),接受两个参数，第一个元素是特定类型的元素的数量，第二个参数是类型的大小**

`int *p = (int *)calloc(10,sizeof(int));`

> malloc和calloc的区别：1.参数不同；2，malloc分配完内存之后不会对其进行初始化，如果没有填入值，会得到一些随机垃圾值。calloc会初始化值为0

* **realloc - void* realloc( void* ptr,size_t size),第一个参数是指向已经分配内存的开始地址的指针，第二个参数是新的内存块的大小**

**运行方式：**如果请求的新块＞之前的块，如果可以拓展之前的块（能在之前的块基础上找到连续的内存），就拓展之前的块，否则就分配新的内存(见下图)。

**realloc用来修改已经动态分配的内存块的大小**

```c++
int n;
printf("Enter size of array\n");
scanf("%d", &n);
//int* A = (int*)malloc(n * sizeof(int)); 如果不进行初始化就都是垃圾值
int* A = (int*)calloc(n,sizeof(int));//此时如果不进行初始化就都是0
for (int i = 0; i < n; i++) {
    A[i] = i + 2;
}
free(A);
A[2]=6;	//free之后还是可以修改A[2]的值 不同的机器可能会崩溃
//realloc
int *B = (int *) realloc(A,2*n*(sizeof(int)));//同时会拷贝之前内存块的内容
int *B = (int *) realloc(A,(n/2)*(sizeof(int)));//保留前两个元素
int *B = (int *) realloc(A,0);		//等价于free(A)
int *B = (int *) realloc(NULL,n*(sizeof(int)));	//等价于malloc
for (int i = 0; i < n; i++) {
    printf("%d", A[i]);
}

```

![image-20230312224235963](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230312224235963.png)

![image-20230312224251653](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230312224251653.png)

***

## 指针和动态内存 - 内存泄露

不正确的使用动态内存，

在栈上，任何程序运行结束后栈帧都会被回收，调用结束分配的内存就会被回收。栈上的内存释放不用程序员担心。**栈上的内存是自动回收的，栈的大小是固定的，最多就是发生栈溢出**

Java和C#，堆上的垃圾会被自动回收（垃圾回收机制）

在堆上，创建内存后一定得手动释放掉，C中使用free()，C++中使用delete

**内存泄露是不当地使用动态内存或者内存的堆区，在一段时间内持续增长**

内存泄露总是因为堆中未使用和未引用的内存块才发生的

![image-20230313090915630](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230313090915630.png)

***

## 函数返回指针

![image-20230313091224555](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230313091224555.png)

![image-20230313091513935](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230313091513935.png)

* **传值：**两个a并不是同一个a，只是进行了值拷贝。其中`main()是主调函数，Add()是被调函数` 
* **传引用：**传地址 

***

![image-20230313091828624](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230313091828624.png)

![image-20230313091913140](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230313091913140.png)

![image-20230313092227225](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230313092227225.png)

![image-20230313092424753](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230313092424753.png)

**总结：从栈底向上传参数是可以的，比如传一个局部变量或者局部变量的地址；反之，从栈顶向下传一个局部变量活着局部变量地址是不可以的**

***

**因此如果想要实现函数返回指针，可以在堆区申请动态内存，返回堆上的指针（保证地址没有被重新使用）或者使用全局区的内存指针**

![image-20230313092936358](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230313092936358.png)

***

## 函数指针

**用来存储函数的地址** 用来解引用或者使用函数 用法如下：

```c
#include <stdio.h>
void PrintHello(char *name) {
	printf("%s hello\n",name);
}

int Add(int a, int b) {
	return a + b;
}
int main() {
	int c;
	int(*p)(int, int);	//定义指向函数的指针 括号必须加 同时指针的类型必须和函数保持一致 传入参数也必须一样
	//p = &Add;	//将Add的地址赋给p 这里不加&也可以 
	p = Add;
	c = p(2, 3);
	//c = (*p)(2, 3);	//函数指针解引用
	printf("c:%d\n", c);
	
	void(*a)(char*);	//如果参数为空，定义 void(*a)();
	a = PrintHello;
	a("tom");

}
```

***

## 函数指针的使用案例（回调函数）

![image-20230313101835915](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230313101835915.png)

![image-20230313101935840](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230313101935840.png)

![image-20230313101733567](https://vicent-picture-for-typora.oss-cn-beijing.aliyuncs.com/img_for_typora/image-20230313101733567.png)

**注意回调函数的用法**

```c
#include <stdio.h>

void A() {
	printf("hello world");
}

void B(void(*ptr)()){	//函数指针作为参数
	ptr();		//回调函数
}

int main() {
	B(A);	//此时A就是一个回调函数
}
```

***
